В Java Memory Model введена такая абстракция как happens-before. Она обозначает, что если операция X связана отношением happens-before с операцией Y, то весь код следуемый за операцией Y, выполняемый в одном потоке, видит все изменения, сделанные другим потоком, до операции X. Список операций связанных отношением happens-before: 1. В рамках одного поток любая операция happens-before любой операцией следующей за ней в исходном коде. 2. Освобождение лока (unlock) happens-before захват того же лока (lock). 3. Выход из synhronized блока/метода happens-before вход в synhronized блок/метод на том же мониторе. 4. Запись volatile поля happens-before чтение того же самого volatile поля. 5. Завершение метода run экземпляра класса Thread happens-before выход из метода join() или возвращение false методом isAlive() экземпляром того же треда. 6. Вызов метода start() экземпляра класса Thread happens-before начало метода run() экземпляра того же треда. 7. Завершение конструктора happens-before начало метода finalize() этого класса. 8. Вызов метода interrupt() на потоке happens-before когда поток обнаружил, что данный метод был вызван либо путем выбрасывания исключения InterruptedException, либо с помощью методов isInterrupted() или interrupted(). Связь happens-before транзитивна, т.е. если X happens-before Y, а Y happens-before Z, то X happens-before Z. Очень важный момент: как освобождение/захват монитора, так и записать/чтение в volatile переменную связаны отношением happens-before, только если операции проводятся над одним и тем же экземпляром объекта. Так же важно понимать, что в отношении happens-before участвуют только два потока, о видимости и reordering остальных потоков ничего сказать нельзя, пока в каждом из них не наступит отношение happens-before с к другим потоком. Еще в отношении happens-before есть очень большой дополительный бонус: данное отношение дает не только видимость volatile полей или результатов операций защищенных монитором или локом, но и видимость вообще всего-всего, что делалось до события hapens-before. ![](https://2.bp.blogspot.com/-YXv36S140Fw/TeXT3zArcGI/AAAAAAAAAvU/_ND1O1Rh2Ks/s400/JMM_happens_before.jpg) Так на рисунке выше ThreadB гарантированно увидит изменение в поле y, сделанное ThreadA, хотя он не является volatile и запись в него происходит вне synchronized блока. Вышеописанные свойства могут достигаться JVM следующим образом: в момент отпускания монитора (записи в volatile переменную и дальше по списку) все регистры и локальные кэши процессора синхронизируются с основной памятью, а в момент последующего захвата лока (чтения volatile переменной и т.д.) процессор на котором выполняется второй поток инвалидирует свой кэш и зачитывает все последние данные из основной памяти. Почему же тогда надо обязательно синхронизироваться на один и тот же монитор, спросите вы? Да потому, что только в этом случае будет гарантироваться строгий порядок, т.е. второй поток гарантировано сбросит свой кэш, только после того как первый синхронизирует свой с основной памятью. Отношение happens-before так же накладывает сильные ограничения на reordering. С точки зрения потока Y все операцие произошедшие до точки happens-before в потоке X он может рассматривать как операции свершившиеся в своем собственном потоке. Т.е. никакого логического reordering по сравнению с прямым порядком в исходном коде с точки зрения потока Y быть не может. Если взглянуть внимательнее на границу happens-before с точки зрения reordering для потока Y, то никакие операции располагающиеся выше границы happens-before в потоке X, не могут выполнится ниже границы happens-before в результате reordering, однако, операциям, находящимся ниже границы, разрешено выполнение до неё. Более наглядно это изображено на рисунке. ![](https://1.bp.blogspot.com/-fpQ4Rf4vnDA/TeXUIXsgLBI/AAAAAAAAAvc/7h-gdBLlOsI/s400/jmm_reordering.png)