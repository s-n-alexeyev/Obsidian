```table-of-contents
title: Содержание:
style: nestedList # TOC style (nestedList|inlineFirstLevel)
minLevel: 0 # Include headings from the specified level
maxLevel: 0 # Include headings up to the specified level
includeLinks: true # Make headings clickable
debugInConsole: false # Print debug info in Obsidian console
```
---

Язык программирования Java обеспечивал поддержку аннотаций с Java 5.0 и выше. Ведущие платформы Java быстро приняли аннотации, и Spring Framework начал использовать аннотации из версии 2.5. Благодаря тому, как они определены, аннотации предоставляют много контекста в их объявлении.

До аннотаций поведение Spring Framework в основном контролировалось с помощью конфигурации XML. Сегодня использование аннотаций предоставляет нам огромные возможности в настройке поведения Spring Framework.

В этой статье мы рассмотрим аннотации, доступные в Spring Framework.

## Основные Spring Framework Аннотации

### @Required

Эта аннотация применяется к методам установки бинов. Рассмотрим сценарий, в котором вам нужно применить обязательное свойство. `@Required` Аннотацию указывает на то, что пострадавшее компонент должен быть заполнен во время конфигурации с требуемым свойством. В противном случае создается исключение типа  `BeanInitializationException` .

### @Autowired

Эта аннотация применяется к полям, методам установки и конструкторам. В  `@Autowired` аннотации впрыскивает объект зависимости неявно.

Когда вы используете `@Autowired` поля и передаете значения для полей, используя имя свойства, Spring автоматически назначает поля с переданными значениями.

Вы даже можете использовать  `@Autowired`  частные объекты, как показано ниже. (Это очень плохая практика!)

```java
public class Customer {
    @Autowired                               
    private Person person;                   
    private int type;
}
```

Когда вы используете  `@Autowired` методы установки, Spring пытается выполнить это, набрав autowiring для этого метода. Вы указываете Spring, что оно должно инициировать это свойство, используя метод установки, в котором вы можете добавить свой собственный код, например, инициализировать любое другое свойство этим свойством.

```java
public class Customer {
    private Person person;
    @Autowired
    public void setPerson (Person person) {
       this.person=person;
    }
}
```

Рассмотрим сценарий, в котором вам нужен экземпляр класса A, но вы не храните A в поле класса. Вы просто используете A для получения экземпляра B и сохраняете B в этом поле. В этом случае сеттер методом автопроводки подойдет вам лучше. У вас не будет неиспользуемых полей на уровне класса.

Когда вы используете  `@Autowired` конструктор, тогда внедрение конструктора происходит во время создания объекта. Он сообщает конструктору об автоматической передаче при использовании в качестве компонента. Здесь следует заметить, что только один конструктор из любого класса бинов может нести  `@Autowired` аннотацию.

```java
@Component
public class Customer {
    private Person person;
    @Autowired
    public Customer (Person person) {
        this.person=person;
    }
}
```

ПРИМЕЧАНИЕ. Начиная с весны 4.3,  `@Autowired` стало необязательным для классов с одним конструктором. В приведенном выше примере Spring по-прежнему внедрит экземпляр класса Person, если вы опустите  `@Autowired` аннотацию.

### @Qualifier

Эта аннотация используется вместе с  `@Autowired` аннотацией. Когда вам нужно больше контроля над процессом внедрения зависимости,  `@Qualifier` можно использовать. `@Qualifier` может быть указано в отдельных аргументах конструктора или параметрах метода. Эта аннотация используется, чтобы избежать путаницы, которая возникает, когда вы создаете несколько бинов одного типа и хотите связать только один из них со свойством.

Рассмотрим пример, где интерфейс  `BeanInterface` реализуется двумя bean-компонентами, BeanB1 и BeanB2.

```java
@Component
public class BeanB1 implements BeanInterface {
    //
}
@Component
public class BeanB2 implements BeanInterface {
    //
}
```

Теперь, если BeanA автоматически подключит этот интерфейс, Spring не будет знать, какую из двух реализаций внедрить.

Одним из решений этой проблемы является использование  `@Qualifier` аннотации.

```java
@Component
public class BeanA {
    @Autowired
    @Qualifier("beanB2")
    private IBean dependency;
    ...
}
```

С  `@Qualifier` добавленной аннотацией Spring теперь будет знать, какой bean-компонент нужно связать автоматически, а где  `beanB2` имя BeanB2.

### @Configuration

Эта аннотация используется для классов, которые определяют bean-компоненты. `@Configuration` является аналогом файла конфигурации XML — он настраивается с использованием классов Java. Класс Java с  `@Configuration` пометкой сам по себе является конфигурацией и будет иметь методы для создания экземпляров и настройки зависимостей.

Вот пример:

```java
@Configuartion
public class DataConfig {
    @Bean
    public DataSource source() {
        DataSource source = new OracleDataSource();
        source.setURL();
        source.setUser();
        return source;
    }
    @Bean
    public PlatformTransactionManager manager() {
        PlatformTransactionManager manager = new BasicDataSourceTransactionManager();
        manager.setDataSource(source());
        return manager;
    }
}
```

### @ComponentScan

Эта аннотация используется вместе с  `@Configuration` аннотацией, чтобы Spring мог узнать, какие пакеты сканируются для аннотированных компонентов. `@ComponentScan` также используется для указания использования базовых пакетов  `basePackageClasses` или  `basePackage` атрибутов для сканирования. Если конкретные пакеты не определены, сканирование будет выполняться из пакета класса, который объявляет эту аннотацию.

### @Bean

Эта аннотация используется на уровне метода. В  `@Bean` аннотации работа с  `@Configuration` создать пружину бобы. Как упоминалось ранее,  `@Configuration`  будут иметь методы для создания экземпляров и настройки зависимостей. Такие методы будут аннотированы  `@Bean`. Метод, аннотированный этой аннотацией, работает как идентификатор компонента, а также создает и возвращает фактический компонент.

Вот пример:

```java
@Configuration
public class AppConfig {
    @Bean
    public Person person() {
        return new Person(address());
    }
    @Bean
    public Address address() {
        return new Address();
    }
}
```

### @Lazy

Эта аннотация используется для классов компонентов. По умолчанию все автосвязные зависимости создаются и настраиваются при запуске. Но если вы хотите лениво инициализировать бин, вы можете использовать  `@Lazy` аннотацию над классом. Это означает, что bean-компонент будет создан и инициализирован только при первом запросе. Вы также можете использовать эту аннотацию на  `@Configuration` занятиях. Это указывает на то, что все  `@Bean` методы в пределах этого  `@Configuration` должны быть лениво инициализированы.

### @Value

Эта аннотация используется на уровнях поля, параметра конструктора и параметра метода. `@Value`  Аннотации указывает выражение на значение по умолчанию для поля или параметра , чтобы инициализировать свойство с. Так как `@Autowired` аннотация говорит Spring, чтобы внедрить объект в другой при загрузке контекста приложения, вы также можете использовать `@Value` аннотацию для вставки значений из файла свойств в атрибут компонента. Он поддерживает заполнители **# {…}** и **$ {…}** .

## Spring Framework Аннотации стереотипов

### @Component

Эта аннотация используется в классах для обозначения компонента Spring. В `@Component` аннотации помечает класс Java , как боб или компонента , так что механизм компонент сканирования весны может добавить его в контекст приложения.

### @Controller

`@Controller` Аннотаций используется для указания класса является контроллером Спринг. Эта аннотация может использоваться для идентификации контроллеров для Spring MVC или Spring WebFlux.

### @Service

Эта аннотация используется в классе. `@Service` помечает класс Java, который выполняет некоторую услугу, такую ​​как выполнение бизнес-логики, выполнение вычислений и вызов внешних API. Эта аннотация является специализированной формой  `@Component` аннотации, предназначенной для использования на сервисном уровне.

### @Repository

Эта аннотация используется в классах Java, которые напрямую обращаются к базе данных. В  `@Repository` аннотации работает как маркер для любого класса , который выполняет роль хранилища или доступ к данным объекта.

Эта аннотация имеет функцию автоматического перевода. Например, когда возникает исключение в   `@Repository`, существует обработчик для этого исключения, и нет необходимости добавлять блок try-catch.

## Spring Boot Annotations

### @EnableAutoConfiguration

Эта аннотация обычно помещается в основной класс приложения. `@EnableAutoConfiguration`  Аннотацию неявно определяет базу «поиск пакетов». Эта аннотация говорит Spring Boot начинать добавление bean-компонентов на основе настроек пути к классам, других bean-компонентов и различных настроек свойств.

### @SpringBootApplication

Эта аннотация используется в классе приложения при настройке проекта Spring Boot. Класс, помеченный знаком,  `@SpringBootApplication`  должен храниться в базовом пакете. Единственное, что  `@SpringBootApplication` делает, — это компонентное сканирование. Но он будет сканировать только свои подпакеты. Например, если вы поместите аннотированный класс  `@SpringBootApplication` в com.example, он  `@SpringBootApplication` будет сканировать все его подпакеты, такие как com.example.a, com.example.b и com.example.ax.

Это  `@SpringBootApplication`  удобная аннотация, которая добавляет все следующее:

-  `@Configuration` 
-  `@EnableAutoConfiguration` 
-  `@ComponentScan` 

## Spring MVC и REST Аннотации

### @Controller

Эта аннотация используется в классах Java, которые играют роль контроллера в вашем приложении.  `@Controller` Аннотаций позволяет автоопределение классов компонентов в пути к классам и автоматическим регистрации бин для них. Чтобы включить автоматическое обнаружение таких аннотированных контроллеров, вы можете добавить компонентное сканирование в вашу конфигурацию. Класс Java с комментариями  `@Controller`  способен обрабатывать несколько сопоставлений запросов.

Эта аннотация может использоваться с Spring MVC и Spring WebFlux.

### @RequestMapping

Эта аннотация используется как на уровне класса, так и на уровне метода.  `@RequestMapping`  Аннотаций используется для отображения веб — запросов на конкретные классы обработчиков и обработчиков методов. Когда  `@RequestMapping` используется на уровне класса, он создает базовый URI, для которого будет использоваться контроллер. Когда эта аннотация используется для методов, она выдаст вам URI, для которого будут выполняться методы-обработчики. Отсюда можно сделать вывод, что сопоставление запросов на уровне класса останется прежним, тогда как у каждого метода-обработчика будет свое сопоставление запросов.

Иногда вам может потребоваться выполнить различные операции в зависимости от используемого метода HTTP, даже если URI запроса может оставаться прежним. В таких ситуациях вы можете использовать атрибут  `@RequestMapping` метода со значением метода HTTP, чтобы сузить методы HTTP для вызова методов вашего класса.

Вот базовый пример того, как работает контроллер вместе с отображениями запросов:

```java
@Controller
@RequestMapping("/welcome")
public class WelcomeController {
    @RequestMapping(method = RequestMethod.GET)
    public String welcomeAll() {
        return "welcome all";
    }
}
```

В этом примере  метод `/welcome` обрабатывает  только запросы GET `welcomeAll()`.

Эта аннотация также может использоваться с Spring MVC и Spring WebFlux.

`@RequestMapping` Аннотация очень универсальна. Пожалуйста, смотрите мой подробный пост о [сопоставлении запросов здесь](https://translate.googleusercontent.com/translate_c?depth=1&pto=aue&rurl=translate.google.ru&sl=en&sp=nmt4&tl=ru&u=http://springframework.guru/spring-requestmapping-annotation/&usg=ALkJrhgB6WnoIX9IPwS2MpvemotyOsljKg) .

### @CookieValue

Эта аннотация используется на уровне параметров метода. `@CookieValue`  используется в качестве аргумента метода отображения запроса. Файл cookie HTTP связан с  `@CookieValue` параметром для данного имени файла cookie. Эта аннотация используется в методе, аннотированном с помощью   `@RequestMapping`.  
Давайте рассмотрим, что следующее значение cookie получено с HTTP-запросом

`JSESSIONID=418AB76CD83EF94U85YD34W`

Чтобы получить значение cookie, используйте @CookieValue следующим образом:

```java
@ReuestMapping("/cookieValue")
    public void getCookieValue(@CookieValue "JSESSIONID"
    String cookie){
}
```

### @CrossOrigin

Эта аннотация используется как на уровне класса, так и на уровне метода для разрешения запросов между источниками. Во многих случаях хост, обслуживающий JavaScript, будет отличаться от хоста, обслуживающего данные. В таком случае кросс-ресурсное совместное использование ресурсов (CORS) обеспечивает междоменную связь. Чтобы включить эту связь, вам просто нужно добавить  `@CrossOrigin`  аннотацию.

По умолчанию  `@CrossOrigin` аннотация допускает все происхождение, все заголовки, методы HTTP, указанные в  `@RequestMapping` аннотации, и maxAge 30 мин. Вы можете настроить поведение, указав соответствующие значения атрибута.

Пример использования  `@CrossOrigin` на уровне методов контроллера и обработчика приведен ниже:

```java
@CrossOrigin(maxAge = 3600)
@RestController
@RequestMapping("/account")
public class AccountController {

    @CrossOrigin(origins = "http://example.com")
    @RequestMapping("/message")
    public Message getMessage() {
        // ...
    }

    @RequestMapping("/note")
    public Note getNote() {
        // ...
    }
}
```

В этом примере, как  `getExample()` и  `getNote()` методы будут иметь MaxAge 3600 секунд. Кроме того,   `getExample()` будут разрешены только запросы о происхождении с сайта http://example.com, а  `getNote()`  запросы всех источников — со всех узлов.

## Составленные варианты @RequestMapping

Spring Framework 4.3 представил следующие варианты `@RequestMapping` аннотаций на уровне методов,  чтобы лучше выразить семантику аннотированных методов. Использование этих аннотаций стало стандартным способом определения конечных точек. Они действуют как обертки для  `@RequestMapping`.

Эти аннотации могут использоваться с Spring MVC и Spring WebFlux.

### @GetMapping

Эта аннотация используется для отображения запросов HTTP GET на определенные методы-обработчики. `@GetMapping` это составная аннотация, которая действует как ярлык для   `@RequestMapping(method = RequestMethod.GET)`.

### @PostMapping

Эта аннотация используется для отображения запросов HTTP POST на определенные методы-обработчики. `@PostMapping` это составная аннотация, которая действует как ярлык для   `@RequestMapping(method = RequestMethod.POST)`.

### @PutMapping

Эта аннотация используется для отображения запросов HTTP PUT на определенные методы-обработчики. `@PutMapping` это составная аннотация, которая действует как ярлык для   `@RequestMapping(method = RequestMethod.PUT)`.

### @PatchMapping

Эта аннотация используется для отображения запросов HTTP PATCH на определенные методы-обработчики. `@PatchMapping` это составная аннотация, которая действует как ярлык для   `@RequestMapping(method = RequestMethod.PATCH)`.

### @DeleteMapping

Эта аннотация используется для отображения запросов HTTP DELETE на определенные методы-обработчики. `@DeleteMapping` это составная аннотация, которая действует как ярлык для   `@RequestMapping(method = RequestMethod.DELETE)`.

### @ExceptionHandler

Эта аннотация используется на уровнях метода для обработки исключений на уровне контроллера. `@ExceptionHandler` Аннотаций используется для определения класса исключения он будет ловить. Вы можете использовать эту аннотацию для методов, которые должны вызываться для обработки исключения. Эти  `@ExceptionHandler` значения могут быть установлены в массив типов исключений. Если выдается исключение, которое соответствует одному из типов в списке, то `@ExceptionHandler` будет вызван метод, аннотированный с сопоставлением  .

### @InitBinder

Эта аннотация является аннотацией уровня метода, которая играет роль идентификации методов, которые инициализируют -a  `WebDataBinder` ,  `DataBinder` который связывает параметр запроса с объектами JavaBean. Чтобы настроить привязку данных параметров запроса, вы можете использовать  `@InitBinder` аннотированные методы в нашем контроллере. Методы, отмеченные как,  `@InitBinder` включают все типы аргументов, которые поддерживаются методами-обработчиками.

В  `@InitBinder` аннотированные методы будут вызываться для каждого запроса HTTP , если не указать значение элемента этой аннотации. Элементом value может быть одно или несколько имен форм или параметров запроса, к которым применяется метод привязки init.

### @Mappings и @Mapping

Эта аннотация используется на полях. `@Mapping` Аннотаций является мета-аннотаций , что указывает на веб — отображение аннотацию. При отображении разных имен полей необходимо настроить исходное поле на его целевое поле, и для этого необходимо добавить  `@Mappings` аннотацию. Эта аннотация принимает массив  `@Mapping` с исходными и целевыми полями.

### @MatrixVariable

Эта аннотация используется для аннотирования аргументов метода обработчика запросов, чтобы Spring мог внедрить соответствующие биты матричного URI. Матричные переменные могут появляться в любом сегменте, каждый из которых разделен точкой с запятой. Если URL-адрес содержит матричные переменные, шаблон отображения запроса должен представлять их с помощью шаблона URI. `@MatrixVariable` Аннотацию гарантирует , что запрос соответствует с правильным матричным переменной URI.

### @PathVariable

Эта аннотация используется для аннотирования аргументов метода обработчика запроса. `@RequestMapping` Аннотации могут быть использованы для обработки динамических изменений в URI , где определенное значение URI , действует в качестве параметра. Вы можете указать этот параметр с помощью регулярного выражения. `@PathVariable` Аннотации могут быть использованы для объявления этого параметра.

### @RequestAttribute

Эта аннотация используется для привязки атрибута запроса к параметру метода обработчика. Spring получает значение именованного атрибута, чтобы заполнить параметр, отмеченный `@RequestAttribute`. Хотя  `@RequestParamannotation` используется для связывания значений параметров из строки запроса,  `@RequestAttribute`  используется для доступа к объектам, которые были заполнены на стороне сервера.

### @RequestBody

Эта аннотация используется для аннотирования аргументов метода обработчика запроса. `@RequestBody` Аннотации указывает на то, что параметр метод должен быть связан с величиной тела запроса HTTP. `HttpMessageConveter` Отвечает за преобразование из сообщения запроса HTTP на объект.

### @RequestHeader

Эта аннотация используется для аннотирования аргументов метода обработчика запроса. `@RequestHeader` Аннотаций используется для отображения параметра контроллера к значению заголовка запроса. Когда Spring отображает запрос,  `@RequestHeader` проверяет заголовок с именем, указанным в аннотации, и связывает его значение с параметром метода-обработчика. Эта аннотация поможет вам получить подробности заголовка в классе контроллера.

### @RequestParam

Эта аннотация используется для аннотирования аргументов метода обработчика запроса. Иногда вы получаете параметры в URL запроса, в основном в запросах GET. В этом случае, наряду с  `@RequestMapping` аннотацией, вы можете использовать  `@RequestParam` аннотацию, чтобы получить параметр URL и сопоставить его с аргументом метода. `@RequestParam` Аннотаций используется для связывания параметров запроса с параметром метода в контроллере.

### @RequestPart

Эта аннотация используется для аннотирования аргументов метода обработчика запроса. `@RequestPart` Аннотаций может быть использован вместо  того `@RequestParam` чтобы получить содержание конкретного многоголосных и привязать его к аргументу методы аннотации   `@RequestPart`. Эта аннотация учитывает заголовок «Content-Type» в составной части (часть запроса).

### @ResponseBody

Эта аннотация используется для аннотирования методов обработчика запросов. `@ResponseBody` Аннотация похожа на  `@RequestBody` аннотацию. `@ResponseBody` Аннотацию указывает на то, что тип результата должен быть записан прямо в теле ответа в любом формате , вы указываете , как JSON или XML. Spring преобразует возвращаемый объект в тело ответа, используя  `HttpMessageConveter`.

### @ResponseStatus

Эта аннотация используется для методов и классов исключений. `@ResponseStatus` помечает метод или класс исключений кодом состояния и причиной, которая должна быть возвращена. Когда вызывается метод-обработчик, для кода состояния устанавливается HTTP-ответ, который переопределяет информацию о состоянии, предоставленную любыми другими средствами. Класс контроллера также может быть аннотирован   `@ResponseStatus`, который затем наследуется всеми  `@RequestMapping` методами.

### @ControllerAdvice

Эта аннотация применяется на уровне класса. Как объяснялось ранее, для каждого контроллера вы можете использовать  `@ExceptionHandler` метод, который будет вызываться при возникновении данного исключения. Но это обрабатывает только те исключения, которые происходят в контроллере, в котором он определен. Чтобы преодолеть эту проблему, теперь вы можете использовать  `@ControllerAdvice` аннотацию. Это примечание используется для определения `@ExceptionHandler`, `@InitBinder`и  `@ModelAttribute` методы , которые применяются ко всем  `@RequestMapping` методам. Таким образом, если вы определите  `@ExceptionHandler` аннотацию для метода в   `@ControllerAdvice` классе, она будет применена ко всем контроллерам.

### @RestController

Эта аннотация используется на уровне класса. В  `@RestController` аннотации класс исполняется в качестве контроллера , где каждый метод возвращает объект домена вместо зрения. Аннотируя класс этой аннотацией, вам больше не нужно добавлять  `@ResponseBody` все  `RequestMapping` методы. Это означает, что вы больше не используете средства разрешения представления или не отправляете HTML в ответ. Вы просто отправляете объект домена в виде HTTP-ответа в формате, понятном потребителям, например JSON.

 `@RestController`  это удобная аннотация, которая сочетает в себе  `@Controller` и   `@ResponseBody`.

### @RestControllerAdvice

Эта аннотация применяется к классам Java. `@RestControllerAdvice` это удобная аннотация, которая сочетает в себе  `@ControllerAdvice` и `@ResponseBody`. Эта аннотация используется вместе с  `@ExceptionHandler` аннотацией для обработки исключений, возникающих в контроллере.

### @SessionAttribute

Эта аннотация используется на уровне параметров метода. `@SessionAttribute` Аннотаций используется для связывания параметра метода в атрибут сеанса. Эта аннотация обеспечивает удобный доступ к существующим или постоянным атрибутам сеанса.

### @SessionAttributes

Эта аннотация применяется на уровне типа для определенного обработчика. `@SessionAtrributes` Аннотаций используется , когда вы хотите добавить JavaBean объекта в сессию. Это используется, когда вы хотите сохранить объект в сеансе на короткое время. `@SessionAttributes` используется в сочетании с `@ModelAttribute`.

Рассмотрим этот пример:

```java
@ModelAttribute("person")
public Person getPerson() {}
// within the same controller as above snippet
@Controller
@SeesionAttributes(value = "person", types = {
    Person.class
})
public class PersonController {}
```

`@ModelAttribute` Имя присваивается в  `@SessionAttributes` качестве значения. `@SessionAttributes` Состоит из двух элементов. Элемент value — это имя сеанса в модели, а элемент types — это тип атрибутов сеанса в модели.

## Spring Cloud Аннотации

### @EnableConfigServer

Эта аннотация используется на уровне класса. При разработке проекта с несколькими службами вам необходимо иметь централизованный и простой способ настройки и извлечения конфигураций всех служб, которые вы собираетесь разрабатывать. Одним из преимуществ использования централизованного сервера конфигурации является то, что вам не нужно нести бремя запоминания того, где каждая конфигурация распределена по нескольким и распределенным компонентам.

Вы можете использовать `@EnableConfigServer` аннотацию Spring Cloud  для запуска сервера конфигурации, с которым могут общаться другие приложения.

### @EnableEurekaServer

Эта аннотация применяется к классам Java. Одна из проблем, с которой вы можете столкнуться при декомпозиции вашего приложения на микросервисы, заключается в том, что каждому сервису становится трудно узнать адрес каждого другого сервиса, от которого он зависит. Приходит служба обнаружения, которая отвечает за отслеживание местоположения всех других микросервисов.

Eureka от Netflix является реализацией сервера обнаружения, а интеграция обеспечивается Spring Boot. Spring Boot упростил проектирование сервера Eureka, просто пометив начальный класс с помощью   `@EnableEurekaServer`.

### @EnableDiscoveryClient

Эта аннотация применяется к классам Java. Чтобы указать любому приложению регистрироваться в Eureka, вам просто нужно добавить  `@EnableDiscoveryClient` аннотацию к точке входа приложения. Приложение, которое теперь зарегистрировано в Eureka, использует абстракцию клиента Spring Cloud Discovery для опроса реестра для своего собственного хоста и порта.

### @EnableCircuitBreaker

Эта аннотация применяется к классам Java, которые могут действовать как прерыватель цепи. Схема автоматического выключателя может позволить микросервису продолжать работу при сбое связанной службы, предотвращая каскадный сбой. Это также дает сбойному сервису время для восстановления.

Класс с пометкой  `@EnableCircuitBreaker`  будет контролировать, размыкать и замыкать автоматический выключатель.

### @HystrixCommand

Эта аннотация используется на уровне метода. Библиотека Hyfrix от Netflix обеспечивает реализацию шаблона прерывателя цепи. Когда вы применяете автоматический выключатель к методу, Hystrix отслеживает сбои метода. Как только сбои нарастают до порогового значения, Hystrix открывает канал, так что последующие вызовы также не срабатывают. Теперь Hystrix перенаправляет вызовы метода, и они передаются указанным резервным методам.

Hystrix ищет любой метод, аннотированный  `@HystrixCommand` аннотацией, и помещает его в прокси-сервер, подключенный к автоматическому выключателю, чтобы Hystrix мог отслеживать его.

Рассмотрим следующий пример:

```java
@Service
public class BookService {
    private final RestTemplate restTemplate;
    public BookService(RestTemplate rest) {
        this.restTemplate = rest;
    }
    @HystrixCommand(fallbackMethod = "newList")
     public String bookList() {
        URI uri = URI.create("http://localhost:8081/recommended");
	    return this.restTemplate.getForObject(uri, String.class);
    }
    public String newList() {
        return "Cloud native Java";
    }
}
```

Здесь  `@HystrixCommand` применяется оригинальный метод   `bookList()`. У  `@HystrixCommand`  аннотации есть  `newList` запасной метод. Поэтому, по какой-то причине, если Hystrix откроет канал   `bookList()`, у вас будет список заполненных книг, готовый для пользователей.

## Spring Framework DataAccess Аннотации

### @Transactional

Эта аннотация помещается перед определением интерфейса, методом на интерфейсе, определением класса или открытым методом на классе. Простого присутствия  `@Transactional` недостаточно для активации транзакционного поведения. Это  `@Transactional` просто метаданные, которые могут использоваться некоторой инфраструктурой времени выполнения. Эта инфраструктура использует метаданные для настройки соответствующих компонентов с поведением транзакций.

Аннотация также поддерживает конфигурацию, такую ​​как:

- Тип распространения транзакции
- Уровень изоляции транзакции
- Тайм-аут для операции, завернутой транзакцией
- Флаг только для чтения — подсказка поставщику постоянства, что транзакция должна быть только для чтения. Правила отката для транзакции.

## Аннотации на основе кэша

### @Cacheable

Эта аннотация используется для методов. Самый простой способ включить поведение кеша для метода — это пометить его  `@Cacheable` и параметризировать его именем кеша, в котором будут храниться результаты.

```java
@Cacheable("addresses")
public String getAddress(Book book){...}
```

В приведенном выше фрагменте метод  `getAddress` связан с кешем с именами адресов. Каждый раз, когда вызывается метод, кэш проверяется, чтобы увидеть, был ли вызов уже выполнен и не должен повторяться.

### @CachePut

Эта аннотация используется для методов. Всякий раз, когда вам нужно обновить кэш, не мешая выполнению метода, вы можете использовать  `@CachePut`  аннотацию. То есть метод всегда будет выполняться, а результат кэшируется.

```
@CachePut("addresses")
public String getAddress(Book book){...}
```

Использование  `@CachePut` и `@Cacheable` использование одного и  того же метода категорически не рекомендуется, поскольку первый вызывает выполнение для выполнения обновления кэша, а последний вызывает пропуск метода с использованием кэша.

### @CacheEvict

Эта аннотация используется для методов. Дело не в том, что вы всегда хотите заполнять кеш все большим количеством данных. Иногда вам может понадобиться удалить некоторые данные из кэша, чтобы вы могли заполнить кэш некоторыми новыми значениями. В таком случае используйте  `@CacheEvict` аннотацию.

```java
@CacheEvict(value="addresses", allEntries="true")
public String getAddress(Book book){...}
```

Здесь, дополнительный элемент,  `allEntries`используется вместе с именем кэша, который должен быть очищен. Он имеет значение true, поэтому он очищает все значения и готовится к хранению новых данных.

### @CacheConfig

Эта аннотация является аннотацией на уровне класса. `@CacheConfig` Аннотаций позволяет упростить некоторые сведения о кэш — памяти на одном месте. Размещение этой аннотации в классе не включает никаких операций кэширования. Это позволяет хранить конфигурацию кеша на уровне класса, чтобы вам не приходилось объявлять что-либо несколько раз.

## Выполнение задач и планирование аннотаций

### @Scheduled

Эта аннотация является аннотацией уровня метода. `@Scheduled` Аннотаций используется на методах наряду с метаданными запуска. Метод с  `@Scheduled` должен иметь возвращаемый тип void и не должен принимать никаких параметров.

Существуют разные способы использования  `@Scheduled` аннотации:

```java
@Scheduled(fixedDelay=5000)
public void doSomething() {
    // something that should execute periodically   
}
```

В этом случае продолжительность между окончанием последнего выполнения и началом следующего выполнения является фиксированной. Задачи всегда ждут окончания предыдущего.

```java
@Scheduled(fixedRate=5000)
public void doSomething() { 
    // something that should execute periodically 
}
```

В этом случае начало выполнения задачи не ожидает завершения предыдущего выполнения.

```java
@Scheduled(initialDelay=1000,fixedRate=5000)
public void doSomething() { 
   // something that should execute periodically after an initial delay  
}
```

Задание сначала выполняется с задержкой, а затем продолжается с указанной фиксированной скоростью.

### @Async

Эта аннотация используется для методов для выполнения каждого метода в отдельном потоке. `@Async` Аннотаций предусмотрен на методе , так что вызов этого метода будет происходить асинхронно. В отличие от методов, помеченных как `@Scheduled`, методы, помеченные как,  `@Async` могут принимать аргументы. Они будут вызываться обычным способом вызывающими во время выполнения, а не по запланированной задаче.

 `@Async` может использоваться как с пустыми методами возвращаемого типа, так и с методами, возвращающими значение. Однако методы с возвращаемыми значениями должны иметь возвращаемое значение типа Future.

## Spring Framework Аннотации для тестирования

### @BootstrapWith

Эта аннотация является аннотацией на уровне класса. `@BootstrapWith`  Аннотаций используется для настройки , как Spring Framework TestContext загрузился. Эта аннотация используется в качестве метаданных для создания пользовательских аннотаций и уменьшения дублирования конфигурации в наборе тестов.

### @ContextConfiguration

Эта аннотация представляет собой аннотацию на уровне класса, которая определяет метаданные, используемые для определения, какие файлы конфигурации использовать для загрузки  `ApplicationContext` теста. Более конкретно,  `@ContextConfiguration`  объявляет аннотированные классы, которые будут использоваться для загрузки контекста. Вы также можете указать Spring, где найти файл.

```java
@ContextConfiguration(locations={"example/test-context.xml", loader = Custom ContextLoader.class})
```

### @WebAppConfiguration

Эта аннотация является аннотацией на уровне класса. `@WebAppConfiguration`  Используется для объявления о том , что  `ApplicationContext` загружен для испытания интеграции должно быть  `WebApplicationContext`. Эта аннотация используется для создания веб-версии контекста приложения. Важно отметить, что эта аннотация должна использоваться с  `@ContextConfiguration`  аннотацией. Путь к корню веб-приложения по умолчанию — src/main/webapp. Вы можете переопределить его, передав другой путь к span class = «theme: classic lang: default decode: true crayon-inline»> `@WebAppConfiguration.`

### @Timed

Эта аннотация используется для методов. `@Timed` Аннотации указывает на то, что аннотированный метод испытания должен завершить свое выполнение в определенный период времени (в миллисекундах). Если выполнение превышает указанное время в аннотации, тест не пройден.

```java
@Timed(millis=10000)
public void testLongRunningProcess() {  ... }
```

В этом примере тест не пройден, если он превышает 10 секунд выполнения.

### @Repeat

Эта аннотация используется в методах испытаний. Если вы хотите запустить тестовый метод несколько раз подряд автоматически, вы можете использовать  `@Repeat` аннотацию. Количество раз, которое метод испытания должен быть выполнен, указано в аннотации.

```java
@Repeat(10)
@Test
public void testProcessRepeatedly() {  ... }
```

В этом примере тест будет выполнен 10 раз.

### @Commit

Эту аннотацию можно использовать как аннотацию как на уровне класса, так и на уровне метода. После выполнения тестового метода транзакция транзакционного метода может быть зафиксирована с использованием  `@Commit` аннотации. Эта аннотация явно передает цель кода. При использовании на уровне класса эта аннотация определяет фиксацию для всех методов тестирования в классе. Когда объявляется как аннотация уровня метода,  `@Commit` указывает фиксацию для определенных методов тестирования, переопределяющих фиксацию уровня класса.

### @RollBack

Эта аннотация может использоваться как аннотация как на уровне класса, так и на уровне метода. `@RollBack` Аннотаций указывает , является ли транзакция транзакционной метода испытаний должен быть произведен откат после завершения проверки его исполнения. Если это правда,   `@Rollback(true)`транзакция откатывается. В противном случае транзакция совершается. `@Commit`  используется вместо   `@RollBack(false)`.

При использовании на уровне класса эта аннотация определяет откат для всех методов тестирования в классе.

Когда объявляется как аннотация уровня метода,   `@RollBack` указывает откат для определенных методов тестирования, переопределяя семантику отката на уровне класса.

### @DirtiesContext

Эта аннотация используется как аннотация как на уровне класса, так и на уровне метода. `@DirtiesContext`  указывает на то, что пружина  `ApplicationContext` была каким-либо образом изменена или повреждена и должна быть закрыта. Это вызовет перезагрузку контекста перед выполнением следующего теста. ApplicationContext помечается как грязный до или после любого такого аннотированного метода, а также до или после текущего класса тестирования.

В @DirtiesContext аннотации опоры   `BEFORE_METHOD`,   `BEFORE_CLASS`и  `BEFORE_EACH_TEST_METHOD`  режимы для закрытия  `ApplicationContext` перед тестом.

**ПРИМЕЧАНИЕ** . Избегайте чрезмерного использования этой аннотации. Это дорогостоящая операция, и в случае злоупотребления она может реально замедлить ваш набор тестов.

### @BeforeTransaction

Эта аннотация используется для аннотирования пустых методов в тестовом классе. `@BeforeTransaction`  аннотированные методы указывают, что они должны быть выполнены до начала выполнения любой транзакции. Это означает, что метод, отмеченный с помощью,  `@BeforeTransaction`  должен быть выполнен до того, как какой-либо метод, отмеченный как   `@Transactional`.

### @AfterTransaction

Эта аннотация используется для аннотирования пустых методов в тестовом классе. `@AfterTransaction` аннотированные методы указывают, что они должны быть выполнены после завершения транзакции для методов тестирования. Это означает, что метод, отмеченный с помощью,  `@AfterTransaction`  должен выполняться после метода, отмеченного с помощью   `@Transactional`.

### @sql

Эта аннотация может быть объявлена ​​в тестовом классе или тестовом методе для запуска сценариев SQL для базы данных. `@Sql`  Аннотацию настраивает путь ресурсов для сценариев SQL , которые должны быть выполнены по отношению к данной базе данных либо до , либо после тестового метода интегрирования. Когда  `@Sql` используется на уровне метода, он переопределяет любой  `@Sqldefined` в уровне класса.

### @SqlConfig

Эта аннотация используется вместе с  `@Sql` аннотацией. `@SqlConfig` Аннотаций определяет метаданные , которые используются для определения того, как анализировать и выполнять сценарии SQL , настроенные с помощью  `@Sql`  аннотаций. При использовании на уровне класса эта аннотация служит глобальной конфигурацией для всех сценариев SQL в тестовом классе. Но при использовании напрямую с атрибутом config   `@Sql`, он  `@SqlConfig` служит локальной конфигурацией для объявленных сценариев SQL.

### @SqlGroup

Эта аннотация используется для методов. `@SqlGroup` Аннотаций представляет собой контейнер аннотации , который может содержать несколько  `@Sql` аннотаций. Эта аннотация может объявлять вложенные  `@Sql` аннотации.  
Кроме того,  `@SqlGroup` используется в качестве метааннотации для создания пользовательских составных аннотаций. Эта аннотация также может использоваться вместе с повторяемыми аннотациями, где она  `@Sql` может быть объявлена ​​несколько раз для одного и того же метода или класса.

### @SpringBootTest

Эта аннотация используется для запуска контекста Spring для интеграционных тестов. Это откроет полный контекст автоконфигурации.

### @DataJpaTest

`@DataJpaTest` Аннотаций только обеспечивает необходимую автоконфигурацию для тестирования Spring Data JPA с использованием базы данных в оперативной памяти , такие как H2.

Эта аннотация используется вместо `@SpringBootTest.` 

### @DataMongoTest

Это  `@DataMongoTest` обеспечит минимальную автоконфигурацию и встроенную MongoDB для запуска интеграционных тестов с Spring Data MongoDB.

### @WebMVCTest

Это  `@WebMVCTest` вызовет фиктивный контекст сервлета для тестирования уровня MVC. Сервисы и компоненты не загружаются в контекст. Чтобы предоставить эти зависимости для тестирования,  `@MockBean`  обычно используется аннотация.

### @AutoConfigureMockMVC

`@AutoConfigureMockMVC` Аннотаций работает очень похоже на  `@WebMVCTest` аннотацию, но запускается полная весна загрузки контекста.

### @MockBean

Создает и внедряет Mockito Mock для данной зависимости.

### @JsonTest

Ограничит автоматическую настройку Spring Boot компонентами, относящимися к обработке JSON.

Это аннотации также автоконфигурирования экземпляра [JacksonTester](https://translate.googleusercontent.com/translate_c?depth=1&pto=aue&rurl=translate.google.ru&sl=en&sp=nmt4&tl=ru&u=https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/test/json/JacksonTester.html&usg=ALkJrhhuylGVyaBLvslEo651cF4zduTL_Q) или [GsonTester](https://translate.googleusercontent.com/translate_c?depth=1&pto=aue&rurl=translate.google.ru&sl=en&sp=nmt4&tl=ru&u=https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/test/json/GsonTester.html&usg=ALkJrhhFblxfhKGnuYLMIsFBGyA8hn6OtA) .

### @TestPropertySource

Аннотация на уровне класса, используемая для указания источников свойств для тестового класса.